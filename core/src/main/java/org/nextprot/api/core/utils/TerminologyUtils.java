package org.nextprot.api.core.utils;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import org.nextprot.api.core.domain.DbXref;
import org.nextprot.api.core.domain.Terminology;
//import org.nextprot.api.core.domain.TerminologyProperty;

public class TerminologyUtils {

	public static List<Terminology.TermProperty> convertToProperties(String propliststring, Long termid, String termacc) {

		if (propliststring == null) return null;
		// Decomposes a pipe-separated string (generated by a SQL query) in a list property objects  containing  name/value pairs
		List<Terminology.TermProperty> properties = new ArrayList<Terminology.TermProperty>();
		// keep spaces in splitting pattern, since pipe alone can occur within fields
		List<String> allprop = Arrays.asList(propliststring.split(" \\| "));
		
		for (String propertystring : allprop) {
			// The splitter is ':=' since both ':' and '=' can occur alone within field
			List<String> currprop = Arrays.asList(propertystring.split(":="));
			if(currprop.size() != 2) {
			   System.err.println("Problem with property in " + termacc + ": " + propertystring);
			   continue;
			}
			Terminology.TermProperty property = new Terminology.TermProperty();
			String propertyName = currprop.get(0) ;
			property.setPropertyName(propertyName);
			String propertyValue = currprop.get(1);
			property.setPropertyValue(propertyValue);
			property.settermId(termid);
			properties.add(property);
		}
		return properties;
	}

	public static List<DbXref> convertToXrefs (String xrefsstring) {

		if (xrefsstring == null) return null;
		// Builds DbXref list from String of xrefs formatted as "dbcat, db, acc" trios separated by pipes
		List<DbXref> xrefs = new ArrayList<DbXref>();
		List<String> allxrefs = Arrays.asList(xrefsstring.split(" \\| "));
		for (String onexref: allxrefs) {
			List<String> fields = Arrays.asList(onexref.split(", "));
			String dbcat = fields.get(0);
			String db = fields.get(1);
			String acc = fields.get(2);
			DbXref dbref = new DbXref();
			dbref.setDatabaseName(db);
			dbref.setAccession(acc);
			dbref.setDatabaseCategory(dbcat);
			//dbref.setDbXrefId(?);
			xrefs.add(dbref);
			}
		return xrefs;
		
	}
	
	public static String convertPropertiesToString(List<Terminology.TermProperty> properties) {

		if (properties == null) return null;
		// Build a String where propertyname/propertyvalue pairs are separated by pipes
		StringBuilder sb = new StringBuilder();
        int i = properties.size();
		for (Terminology.TermProperty property : properties) {
			sb.append(property.getPropertyName());
			sb.append(":=");
			sb.append(property.getPropertyValue());
			if(--i != 0)
			  sb.append(" | ");
		}
		return sb.toString();
	}

	public static String convertXrefsToString(List<DbXref> xrefs) {

		if (xrefs == null) return null;
		// Build a String of xrefs formatted as "dbcat, db:acc" pairs separated by pipes
		StringBuilder sb = new StringBuilder();
        int i = xrefs.size();
		for (DbXref xref : xrefs) {
			sb.append(xref.getDatabaseCategory());
			sb.append(", ");
			sb.append(xref.getDatabaseName());
			sb.append(":");
			sb.append(xref.getAccession());
			if(--i != 0)
			  sb.append(" | ");
		}
		return sb.toString();
	}

	public static String convertXrefsToSolrString(List<DbXref> xrefs) {

		if (xrefs == null) return null;
		// Build a String of xrefs for solr formatted as "acc, db:acc" pairs separated by pipes
		StringBuilder sb = new StringBuilder();
        int i = xrefs.size();
		for (DbXref xref : xrefs) {
			sb.append(xref.getAccession());
			sb.append(", ");
			sb.append(xref.getDatabaseName());
			sb.append(":");
			sb.append(xref.getAccession());
			if(--i != 0)
			  sb.append(" | ");
		}
		return sb.toString();
	}

	public static List<String> convertXrefsToSameAsStrings(List<DbXref> xrefs) {

		if (xrefs == null) return null;
		// Build List of strings of xref accessions  as needed for the old Terminology.getSameAs method
		List<String> sameas = new ArrayList<String>();
		for (DbXref xref : xrefs) {
			sameas.add(xref.getAccession());
		}
		return sameas;
	}
}
